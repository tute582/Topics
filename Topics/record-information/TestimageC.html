<!DOCTYPE html>
<html lang="zh-TW">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>éš±ç§è³‡æ–™é®è”½å·¥å…· (UIå„ªåŒ–ç‰ˆ)</title>
    <style>
      body {
        font-family: sans-serif;
        padding: 20px;
        /* [ä¿®æ”¹] æ”¹ç‚ºé å·¦å°é½Š */
        text-align: left;
        overscroll-behavior: none;
      }

      .container {
        /* [ä¿®æ”¹] ç§»é™¤ max-width å’Œ margin: 0 autoï¼Œè®“å®ƒè‡ªç„¶é å·¦ä¸¦å¡«æ»¿ iframe */
        width: 100%;
        margin: 0;
      }

      /* --- å·¥å…·åˆ— (ä¸Šæ–¹) --- */
      .tools-bar {
        display: none;
        /* [ä¿®æ”¹] é å·¦æ’åˆ— */
        justify-content: flex-start;
        gap: 15px; /* å¢åŠ ä¸€é»é–“è· */
        align-items: center;
        margin-bottom: 5px;
        padding: 10px;
        background-color: #f8f9fa;
        border-radius: 8px;
        border: 1px solid #ddd;
      }

      .tool-label {
        font-size: 14px;
        color: #555;
        font-weight: bold;
      }

      /* ç•«å¸ƒå®¹å™¨ */
      #canvas-container {
        width: 100%;
        overflow: hidden;
        border: 2px dashed #ccc;
        touch-action: none;
        display: none;
        background-color: #eee;
        margin-top: 10px;
      }

      canvas {
        max-width: 100%;
        height: auto;
        display: block;
        /* [ä¿®æ”¹] ç§»é™¤ margin: 0 auto (ç½®ä¸­)ï¼Œæ”¹ç‚ºé å·¦ */
        margin: 0;
        cursor: crosshair;
      }

      /* æŒ‰éˆ•æ¨£å¼ */
      .btn {
        padding: 10px 20px;
        font-size: 16px;
        cursor: pointer;
        border: none;
        border-radius: 5px;
        transition: opacity 0.2s;
      }
      .btn:active {
        opacity: 0.8;
      }

      /* å¾©åŸæŒ‰éˆ• */
      #undoBtn {
        background-color: #ff9800;
        color: white;
        font-size: 14px;
        padding: 8px 15px;
      }
      #undoBtn:disabled {
        background-color: #e0e0e0;
        color: #999;
        cursor: not-allowed;
      }

      /* ç¢ºèªæŒ‰éˆ• */
      #confirmBtn {
        background-color: #4caf50;
        color: white;
        display: none;
        width: 100%;
        margin-top: 15px;
        padding: 15px;
        font-size: 18px;
        font-weight: bold;
      }

      /* æç¤ºæ–‡å­— */
      #hintText {
        display: none;
        color: #d9534f;
        margin: 15px 0;
        text-align: left; /* ä¿æŒé å·¦ */
        font-size: 14px;
        background: #fff5f5;
        padding: 10px;
        border-radius: 5px;
      }

      h2 {
        margin-top: 0;
        font-size: 20px; /* ç¨å¾®èª¿æ•´æ¨™é¡Œå¤§å°ä»¥é…åˆæ•´é«” */
      }

      /* Loading Overlay */
      .loading-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(255, 255, 255, 0.85);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 9999;
      }

      .loading-box {
        text-align: center;
        padding: 30px 40px;
        background: #ffffff;
        border-radius: 12px;
        box-shadow: 0 8px 30px rgba(0, 0, 0, 0.1);
      }

      .spinner {
        width: 48px;
        height: 48px;
        border: 5px solid #e0e0e0;
        border-top-color: #4caf50;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin: 0 auto 20px;
      }

      .loading-text {
        font-size: 15px;
        color: #333;
        line-height: 1.6;
      }

      .loading-text span {
        font-size: 13px;
        color: #777;
      }

      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

    </style>
  </head>
  <body>
    <div class="container">
      <h2>æ­¥é©Ÿ 1: ä¸Šå‚³ç…§ç‰‡</h2>
      <p style="color: #666; margin-bottom: 20px">
        ä¸Šå‚³çœ‹è¨ºå–® / è—¥è¢‹ï¼ˆæ‹ç…§æˆ–ç›¸ç°¿ï¼‰
      </p>

      <input
        type="file"
        id="imageInput"
        accept="image/*"
        capture="environment"
        multiple
      />

      <div id="hintText">
        <strong>ğŸ’¡ æ­¥é©Ÿ 2: é®è”½å€‹è³‡</strong><br />
        è«‹ç›´æ¥åœ¨åœ–ç‰‡ä¸Šæ»‘å‹•æ‰‹æŒ‡ï¼Œå¡—é»‘<strong>å§“å</strong>èˆ‡<strong>èº«åˆ†è­‰è™Ÿ</strong>ã€‚
      </div>

      <div class="tools-bar" id="toolsBar">
        <button id="undoBtn" class="btn" disabled>â†º å¾©åŸä¸Šä¸€æ­¥</button>
      </div>

      <div id="canvas-container">
        <canvas id="imageCanvas"></canvas>
      </div>

      <button id="confirmBtn" class="btn">ç¢ºèªå®‰å…¨ï¼Œé€å‡ºè¾¨è­˜ â¤</button>

      <!-- AI è¾¨è­˜ä¸­é®ç½© -->
      <div id="loadingOverlay" class="loading-overlay">
        <div class="loading-box">
          <div class="spinner"></div>
          <div class="loading-text">
            æ­£åœ¨ç‚ºæ‚¨è¾¨è­˜åœ–ç‰‡ä¸­çš„æ–‡å­—è³‡è¨Š<br />
            <span>è«‹ç¨å€™ï¼Œé€™å¯èƒ½éœ€è¦ç´„ 10ï½30 ç§’</span>
          </div>
        </div>
      </div>

    <script>
      const imageInput = document.getElementById("imageInput");
      const canvasContainer = document.getElementById("canvas-container");
      const canvas = document.getElementById("imageCanvas");
      const ctx = canvas.getContext("2d");

      // UI å…ƒç´ 
      const toolsBar = document.getElementById("toolsBar");
      const confirmBtn = document.getElementById("confirmBtn");
      const undoBtn = document.getElementById("undoBtn");
      const hintText = document.getElementById("hintText");
      const loadingOverlay = document.getElementById("loadingOverlay");

      // è®Šæ•¸è¨­å®š
      let isDrawing = false;
      let baseImage = null;

      // æ­·å²ç´€éŒ„ç³»çµ±
      let historyStrokes = [];
      let currentStroke = [];

      const brushSize = 35;
      const brushColor = "#000000";

      // --- 1. åœ–ç‰‡è¼‰å…¥ ---
      imageInput.addEventListener("change", (e) => {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (event) => {
          const img = new Image();
          img.onload = () => {
            canvas.width = img.width;
            canvas.height = img.height;
            baseImage = img;
            historyStrokes = [];
            updateUndoButton();
            ctx.drawImage(img, 0, 0);

            hintText.style.display = "block";
            toolsBar.style.display = "flex";
            canvasContainer.style.display = "block";
            confirmBtn.style.display = "block";
            setupBrush();
          };
          img.src = event.target.result;
        };
        reader.readAsDataURL(file);
      });

      function setupBrush() {
        ctx.strokeStyle = brushColor;
        ctx.lineWidth = brushSize;
        ctx.lineJoin = "round";
        ctx.lineCap = "round";
      }

      // --- 2. ç¹ªåœ–æ ¸å¿ƒé‚è¼¯ ---
      function getPos(e) {
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        return {
          x: (clientX - rect.left) * scaleX,
          y: (clientY - rect.top) * scaleY,
        };
      }

      function startDrawing(e) {
        isDrawing = true;
        const pos = getPos(e);
        currentStroke = [pos];
        ctx.beginPath();
        ctx.moveTo(pos.x, pos.y);
        ctx.lineTo(pos.x, pos.y);
        ctx.stroke();
        e.preventDefault();
      }

      function draw(e) {
        if (!isDrawing) return;
        const pos = getPos(e);
        currentStroke.push(pos);
        const lastPoint = currentStroke[currentStroke.length - 2];
        ctx.beginPath();
        ctx.moveTo(lastPoint.x, lastPoint.y);
        ctx.lineTo(pos.x, pos.y);
        ctx.stroke();
        e.preventDefault();
      }

      function stopDrawing() {
        if (!isDrawing) return;
        isDrawing = false;
        if (currentStroke.length > 0) {
          historyStrokes.push(currentStroke);
          updateUndoButton();
        }
      }

      // --- 3. é‡ç¹ªåŠŸèƒ½ (Undo) ---
      function redrawCanvas() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        if (baseImage) {
          ctx.drawImage(baseImage, 0, 0);
        }
        setupBrush();
        historyStrokes.forEach((stroke) => {
          if (stroke.length === 0) return;
          ctx.beginPath();
          ctx.moveTo(stroke[0].x, stroke[0].y);
          stroke.forEach((point, index) => {
            if (index > 0) ctx.lineTo(point.x, point.y);
          });
          ctx.stroke();
        });
      }

      undoBtn.addEventListener("click", () => {
        if (historyStrokes.length === 0) return;
        historyStrokes.pop();
        redrawCanvas();
        updateUndoButton();
      });

      function updateUndoButton() {
        undoBtn.disabled = historyStrokes.length === 0;
        undoBtn.style.opacity = historyStrokes.length === 0 ? "0.5" : "1";
      }

      // äº‹ä»¶ç›£è½
      canvas.addEventListener("mousedown", startDrawing);
      canvas.addEventListener("mousemove", draw);
      canvas.addEventListener("mouseup", stopDrawing);
      canvas.addEventListener("mouseout", stopDrawing);

      canvas.addEventListener("touchstart", startDrawing, { passive: false });
      canvas.addEventListener("touchmove", draw, { passive: false });
      canvas.addEventListener("touchend", stopDrawing);
      canvas.addEventListener("touchcancel", stopDrawing);

      // --- 4. ç¢ºèªè¼¸å‡º ---
      confirmBtn.addEventListener("click", async () => {
        const base64Full = canvas.toDataURL("image/jpeg", 0.8);
        const base64Data = base64Full.split(",")[1];

        // âœ… é¡¯ç¤º loading
        loadingOverlay.style.display = "flex";
        confirmBtn.disabled = true;

        console.log("Ready to send:", base64Data.substring(0, 30));

        // ğŸ”„ å‘¼å«å¾Œç«¯ API
        try {
          const response = await fetch(
            "https://supabase-api-six.vercel.app/photoCapture",
            {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
              },
              body: JSON.stringify({
                base64: base64Data,
              }),
            }
          );
          const result = await response.json();

          if (!result.success) {
            console.log(result.message + "\n\nAI å›è¦†å…§å®¹ï¼š\n" + result.rawText);
            alert("AI è¾¨è­˜å¤±æ•—ï¼Œè«‹ç¨å¾Œå†è©¦");
          } else {
            console.log("AI è¾¨è­˜æˆåŠŸï¼š", result.data);
            alert("è¾¨è­˜å®Œæˆï¼");
          }
        } catch (err) {
          console.error("API å‘¼å«å¤±æ•—:", err);
          alert("ç³»çµ±é€£ç·šå¤±æ•—ï¼Œè«‹æª¢æŸ¥ç¶²è·¯");
        } finally {
          // é—œæ‰ loading
          loadingOverlay.style.display = "none";
          confirmBtn.disabled = false;
        }
      });
    </script>
  </body>
</html>
