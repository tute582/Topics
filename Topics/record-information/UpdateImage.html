<!DOCTYPE html>
<html lang="zh-TW">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>éš±ç§è³‡æ–™é®è”½å·¥å…· (UIå„ªåŒ–ç‰ˆ)</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
    <style>
      body {
        font-family: "PingFang TC", "Microsoft JhengHei", sans-serif;
        padding: 0px;
        text-align: center; /*è®“å…§å®¹ç½®ä¸­*/
        overscroll-behavior: none;
        overflow: hidden; 
        margin: 0;
        background-color: transparent; /* [ä¿®æ”¹] èƒŒæ™¯é€æ˜ */
        
        /* [ä¿®æ”¹] è®“åˆå§‹æŒ‰éˆ•å‚ç›´ç½®ä¸­ */
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        min-height: 50px; /* é…åˆ iframe é«˜åº¦ */
      }

      .container {
        width: 100%;
        margin: 0;
        display: flex;
        flex-direction: column;
        align-items: center;
      }

      /* [ä¿®æ”¹] è‡ªè¨‚ä¸Šå‚³æŒ‰éˆ•æ¨£å¼ (ç¶ è‰²ã€åœ“è§’ã€ä¸è²¼é‚Š) */
      .custom-upload-btn {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
        background-color: #2ecc71; /* ç¶ è‰² */
        color: white;
        padding: 10px 25px;
        border-radius: 15px;
        font-size: 16px;
        font-weight: bold;
        cursor: pointer;
        border: none;
        box-shadow: 0 2px 5px rgba(0,0,0,0.15);
        transition: transform 0.1s;
        margin-bottom: 10px; /* èˆ‡ä¸‹æ–¹å…§å®¹çš„é–“è· */
      }

      .custom-upload-btn:active {
        transform: scale(0.95);
      }

      /* [ä¿®æ”¹] éš±è—åŸæœ¬çš„ input */
      #imageInput {
        display: none;
      }

      /* --- å·¥å…·åˆ— (ä¸Šæ–¹) --- */
      .tools-bar {
        display: none;
        justify-content: center; /* ç½®ä¸­ */
        gap: 15px;
        align-items: center;
        margin-bottom: 5px;
        padding: 10px;
        background-color: #f8f9fa;
        border-radius: 8px;
        border: 1px solid #ddd;
        width: 90%; /* å¯¬åº¦é™åˆ¶ */
      }

      /* ç•«å¸ƒå®¹å™¨ */
      #canvas-container {
        width: 100%;
        overflow: hidden;
        border: 2px dashed #ccc;
        touch-action: none;
        display: none;
        background-color: #eee;
        margin-top: 5px;
      }

      canvas {
        max-width: 100%;
        height: auto;
        display: block;
        margin: 0 auto; /* ç½®ä¸­ */
        cursor: crosshair;
      }

      /* æŒ‰éˆ•æ¨£å¼ */
      .btn {
        padding: 10px 20px;
        font-size: 16px;
        cursor: pointer;
        border: none;
        border-radius: 5px;
        transition: opacity 0.2s;
      }
      .btn:active {
        opacity: 0.8;
      }

      /* å¾©åŸæŒ‰éˆ• */
      #undoBtn {
        background-color: #ff9800;
        color: white;
        font-size: 14px;
        padding: 8px 15px;
      }
      #undoBtn:disabled {
        background-color: #e0e0e0;
        color: #999;
        cursor: not-allowed;
      }

      /* ç¢ºèªæŒ‰éˆ• */
      #confirmBtn {
        background-color: #4caf50;
        color: white;
        display: none;
        width: 90%; /* é…åˆæ•´é«”å¯¬åº¦ */
        margin-top: 15px;
        padding: 15px;
        font-size: 18px;
        font-weight: bold;
        border-radius: 15px;
      }

      /* æç¤ºæ–‡å­— */
      #hintText {
        display: none;
        color: #d9534f;
        margin: 10px 0;
        text-align: center;
        font-size: 14px;
        background: #fff5f5;
        padding: 10px;
        border-radius: 5px;
        width: 90%;
      }

      /* Loading Overlay */
      .loading-overlay {
        position: fixed;
        top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(255, 255, 255, 0.85);
        display: none;
        align-items: center; justify-content: center;
        z-index: 9999;
      }
      .loading-box {
        text-align: center; padding: 30px 40px;
        background: #ffffff; border-radius: 12px;
        box-shadow: 0 8px 30px rgba(0, 0, 0, 0.1);
      }
      .spinner {
        width: 48px; height: 48px;
        border: 5px solid #e0e0e0; border-top-color: #4caf50;
        border-radius: 50%; animation: spin 1s linear infinite;
        margin: 0 auto 20px;
      }
      .loading-text { font-size: 15px; color: #333; line-height: 1.6; }
      .loading-text span { font-size: 13px; color: #777; }
      @keyframes spin { to { transform: rotate(360deg); } }

    </style>
  </head>
  <body>
    <div class="container">
      
      <label class="custom-upload-btn" id="uploadLabel">
        <i class="fa-solid fa-camera"></i>
        <span>é¸æ“‡æª”æ¡ˆ / æ‹ç…§</span>
        <input
          type="file"
          id="imageInput"
          accept="image/*"
          capture="environment"
          multiple
        />
      </label>
      
      <div id="hintText">
        <strong>ğŸ’¡ é®è”½å€‹è³‡</strong><br />
        è«‹ç›´æ¥åœ¨åœ–ç‰‡ä¸Šæ»‘å‹•æ‰‹æŒ‡ï¼Œå¡—é»‘<strong>å§“å</strong>èˆ‡<strong>èº«åˆ†è­‰è™Ÿ</strong>ã€‚
      </div>

      <div class="tools-bar" id="toolsBar">
        <button id="undoBtn" class="btn" disabled>â†º å¾©åŸä¸Šä¸€æ­¥</button>
      </div>

      <div id="canvas-container">
        <canvas id="imageCanvas"></canvas>
      </div>

      <button id="confirmBtn" class="btn">ç¢ºèªå®‰å…¨ï¼Œé€å‡ºè¾¨è­˜ â¤</button>

      <div id="loadingOverlay" class="loading-overlay">
        <div class="loading-box">
          <div class="spinner"></div>
          <div class="loading-text">
            æ­£åœ¨ç‚ºæ‚¨è¾¨è­˜åœ–ç‰‡ä¸­çš„æ–‡å­—è³‡è¨Š<br />
            <span>è«‹ç¨å€™ï¼Œé€™å¯èƒ½éœ€è¦ç´„ 10ï½30 ç§’</span>
          </div>
        </div>
      </div>
    </div>

    <script>
      const imageInput = document.getElementById("imageInput");
      const canvasContainer = document.getElementById("canvas-container");
      const canvas = document.getElementById("imageCanvas");
      const ctx = canvas.getContext("2d");

      // UI å…ƒç´ 
      const toolsBar = document.getElementById("toolsBar");
      const confirmBtn = document.getElementById("confirmBtn");
      const undoBtn = document.getElementById("undoBtn");
      const hintText = document.getElementById("hintText");
      const loadingOverlay = document.getElementById("loadingOverlay");
      const uploadLabel = document.getElementById("uploadLabel"); // å–å¾—æŒ‰éˆ• Label

      // è®Šæ•¸è¨­å®š
      let isDrawing = false;
      let baseImage = null;

      // æ­·å²ç´€éŒ„ç³»çµ±
      let historyStrokes = [];
      let currentStroke = [];

      const brushSize = 35;
      const brushColor = "#000000";

      // æ ¸å¿ƒåŠŸèƒ½ï¼šè¨ˆç®—ç•¶å‰é«˜åº¦ä¸¦å‚³çµ¦å¤–å±¤
      function sendHeightToParent() {
        const height = document.body.scrollHeight;
        window.parent.postMessage({ type: 'resize-iframe', height: height }, '*');
      }

      window.addEventListener('load', sendHeightToParent);
      window.addEventListener('resize', sendHeightToParent);

      // --- 1. åœ–ç‰‡è¼‰å…¥ ---
      imageInput.addEventListener("change", (e) => {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (event) => {
          const img = new Image();
          img.onload = () => {
            canvas.width = img.width;
            canvas.height = img.height;
            baseImage = img;
            historyStrokes = [];
            updateUndoButton();
            ctx.drawImage(img, 0, 0);

            // é¡¯ç¤ºåŸæœ¬éš±è—çš„å·¥å…·åˆ—èˆ‡ç•«å¸ƒ
            hintText.style.display = "block";
            toolsBar.style.display = "flex";
            canvasContainer.style.display = "block";
            confirmBtn.style.display = "block";
            setupBrush();
            
            // åœ–ç‰‡è¼‰å…¥å¾Œï¼Œå¯ä»¥è€ƒæ…®éš±è—ä¸Šå‚³æŒ‰éˆ•ï¼Œæˆ–æ˜¯æ”¹è®Šæ–‡å­—(è¦–éœ€æ±‚è€Œå®š)
            // é€™è£¡ä¿ç•™æŒ‰éˆ•ä»¥ä¾¿é‡æ–°ä¸Šå‚³ï¼Œä½†æ–‡å­—å¯ä»¥æ”¹æˆ "é‡æ–°ä¸Šå‚³"
            uploadLabel.querySelector('span').innerText = "é‡æ–°é¸æ“‡åœ–ç‰‡";

            setTimeout(sendHeightToParent, 100);
          };
          img.src = event.target.result;
        };
        reader.readAsDataURL(file);
      });

      function setupBrush() {
        ctx.strokeStyle = brushColor;
        ctx.lineWidth = brushSize;
        ctx.lineJoin = "round";
        ctx.lineCap = "round";
      }

      // --- 2. ç¹ªåœ–æ ¸å¿ƒé‚è¼¯ ---
      function getPos(e) {
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        return {
          x: (clientX - rect.left) * scaleX,
          y: (clientY - rect.top) * scaleY,
        };
      }

      function startDrawing(e) {
        isDrawing = true;
        const pos = getPos(e);
        currentStroke = [pos];
        ctx.beginPath();
        ctx.moveTo(pos.x, pos.y);
        ctx.lineTo(pos.x, pos.y);
        ctx.stroke();
        e.preventDefault();
      }

      function draw(e) {
        if (!isDrawing) return;
        const pos = getPos(e);
        currentStroke.push(pos);
        const lastPoint = currentStroke[currentStroke.length - 2];
        ctx.beginPath();
        ctx.moveTo(lastPoint.x, lastPoint.y);
        ctx.lineTo(pos.x, pos.y);
        ctx.stroke();
        e.preventDefault();
      }

      function stopDrawing() {
        if (!isDrawing) return;
        isDrawing = false;
        if (currentStroke.length > 0) {
          historyStrokes.push(currentStroke);
          updateUndoButton();
        }
      }

      // --- 3. é‡ç¹ªåŠŸèƒ½ (Undo) ---
      function redrawCanvas() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        if (baseImage) {
          ctx.drawImage(baseImage, 0, 0);
        }
        setupBrush();
        historyStrokes.forEach((stroke) => {
          if (stroke.length === 0) return;
          ctx.beginPath();
          ctx.moveTo(stroke[0].x, stroke[0].y);
          stroke.forEach((point, index) => {
            if (index > 0) ctx.lineTo(point.x, point.y);
          });
          ctx.stroke();
        });
      }

      undoBtn.addEventListener("click", () => {
        if (historyStrokes.length === 0) return;
        historyStrokes.pop();
        redrawCanvas();
        updateUndoButton();
      });

      function updateUndoButton() {
        undoBtn.disabled = historyStrokes.length === 0;
        undoBtn.style.opacity = historyStrokes.length === 0 ? "0.5" : "1";
      }

      // äº‹ä»¶ç›£è½
      canvas.addEventListener("mousedown", startDrawing);
      canvas.addEventListener("mousemove", draw);
      canvas.addEventListener("mouseup", stopDrawing);
      canvas.addEventListener("mouseout", stopDrawing);

      canvas.addEventListener("touchstart", startDrawing, { passive: false });
      canvas.addEventListener("touchmove", draw, { passive: false });
      canvas.addEventListener("touchend", stopDrawing);
      canvas.addEventListener("touchcancel", stopDrawing);

      // --- 4. ç¢ºèªè¼¸å‡º ---
      confirmBtn.addEventListener("click", async () => {
        const base64Full = canvas.toDataURL("image/jpeg", 0.8);
        const base64Data = base64Full.split(",")[1];

        // é€šçŸ¥ parent é¡¯ç¤º loading
        window.parent.postMessage({ type: 'show-loading' }, '*');
        
        confirmBtn.disabled = true;

        console.log("Ready to send:", base64Data.substring(0, 30));

        // ğŸ”„ å‘¼å«å¾Œç«¯ API
        try {
          const response = await fetch(
            "https://supabase-api-six.vercel.app/photoCapture",
            {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
              },
              body: JSON.stringify({
                base64: base64Data,
              }),
            }
          );
          const result = await response.json();

          if (!result.success) {
            console.log(result.message + "\n\nAI å›è¦†å…§å®¹ï¼š\n" + result.rawText);
            alert("AI è¾¨è­˜å¤±æ•—ï¼Œè«‹ç¨å¾Œå†è©¦");
          } else {
            console.log("AI è¾¨è­˜æˆåŠŸï¼š", result.data);
            
            // å›å‚³è³‡æ–™çµ¦ parent
            window.parent.postMessage({
                type: 'fill-data',
                data: result.data,
                base64: base64Data 
            }, '*');
            
            alert("è¾¨è­˜å®Œæˆï¼");
          }
        } catch (err) {
          console.error("API å‘¼å«å¤±æ•—:", err);
          alert("ç³»çµ±é€£ç·šå¤±æ•—ï¼Œè«‹æª¢æŸ¥ç¶²è·¯");
        } finally {
          // é€šçŸ¥ parent éš±è— loading
          window.parent.postMessage({ type: 'hide-loading' }, '*');
          
          confirmBtn.disabled = false;
        }
      });
    </script>
  </body>
</html>